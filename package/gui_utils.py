import os
import pickle
import tkinter as tk
from datetime import datetime
from pathlib import Path
from tkinter import ttk
from typing import NamedTuple

import matplotlib.pyplot as plt
import numpy as np
import pyroomacoustics as pra
from matplotlib.figure import Figure

## Default config options for RIRg_GUI
DEFAULT_NMICS: int = 5
DEFAULT_DIST_BW_MICS: int = 5
DEFAULT_ROOMDIM: int = 5
DEFAULT_T60: float = 0.0
DEFAULT_RIR_LENGTH: int = 22050
DEFAULT_FS: int = 44100

ELEMENT_COLORS: dict[str, str] = {"mic": "blue", "audio": "red", "noise": "black"}
ELEMENT_RADIUS: int = 10


class Asc(NamedTuple):
    """
    Immutable class containing all relevant data generated by the `RIRg_GUI`
    when performing the `create/store RIRs` action.
    """

    c: float
    t60: float
    fs: float
    roomDim: float
    rirLength: int
    micPos: np.ndarray
    audioPos: np.ndarray
    noisePos: np.ndarray
    RIRs_audio: np.ndarray
    RIRs_noise: np.ndarray

    def __repr__(self):
        """Convert to a string for plotting"""

        excluded = ["RIRs_audio", "RIRs_noise"]

        reprs: list[str] = [
            (
                f">> {key}: {value}"
                if key not in excluded
                else (
                    f">> {key}: numpy array of shape {value.shape}"
                    if value is not None
                    else f">> {key}: None"
                )
            )
            for key, value in self._asdict().items()
        ]

        return "Acoustic scenario parameters:\n" + "\n".join(reprs)


class RIRg_GUI:
    """
    Class that, upon construction, starts the GUI for RIR generation. When the
    RIRs are generated they can then be extracted into a `asc` class by loading
    the pickle archive.
    """

    def __init__(
        self,
        c: float = 340,  # speed of sound [m/s]
        nMicsPerArray: int = 5,
        distBwMics: float = 5.0,  # [cm]
        roomDim: float = 5.0,  # [m]
        t60: float = 0,  # [s]
        rirLength: int = 22050,  # in samples
        fs: int = 44100,  # [Hz]
        exportFolder: str = os.path.join(os.getcwd(), "rirs"),
    ):
        ## Base objects for GUI, has to happen prior to doing anything else Tk related
        self.root: tk.Tk = tk.Tk()  # base instance of the GUI
        self.root.title("P&D ISSP GUI")
        self.root.resizable(False, False)
        self.mainframe: ttk.Frame = ttk.Frame(self.root, padding=(3, 3, 12, 12))
        self.mainframe.grid(column=0, row=0, sticky="nwes")

        ## Register input parameters, already register them as Tkinter objects
        # as they will be used like that later on.
        self.c: float = c
        self.nMicsPerArray: tk.StringVar = tk.StringVar(value=str(nMicsPerArray))
        self.distBwMics: tk.StringVar = tk.StringVar(value=str(distBwMics))
        self.roomDim: tk.StringVar = tk.StringVar(value=str(roomDim))
        self.t60: tk.StringVar = tk.StringVar(value=str(t60))
        self.rirLength: tk.StringVar = tk.StringVar(value=str(rirLength))
        self.allowed_fs: list[int] = [44100, 16000, 8000]
        if fs < min(self.allowed_fs):
            print(
                f"Desired sampling frequency too low ({fs} Hz), setting fs = "
                f"{min(self.allowed_fs)} kHz."
            )
            fs = min(self.allowed_fs)
        elif fs not in self.allowed_fs:
            print(
                f"Only allowed sampling frequencies are "
                f"{', '.join(map(str, self.allowed_fs))}, choosing the closest one."
            )
            fs = self.allowed_fs[np.argmin(np.abs(np.array(self.allowed_fs) - fs))]
        self.fs: tk.StringVar = tk.StringVar(value=str(fs))
        self.exportFolder: str = exportFolder

        ## Location storage
        self.option: tk.StringVar = tk.StringVar(value="mic")
        self.audioCoords: list[tuple[float, float]] = []
        self.noiseCoords: list[tuple[float, float]] = []
        self.micCoords: list[tuple[float, float]] = []

        ## RIRs
        self.RIRsAudio: np.ndarray = None
        self.RIRsNoise: np.ndarray = None

        ## Start GUI
        self.make_window()

    def __repr__(self) -> str:
        strout = (
            "Acoustic scenario object allowing to construct the RIRs with parameters:"
        )
        objs: dict[str, object] = {
            "c": self.c,
            "t60": self.t60.get(),
            "roomDim": self.roomDim.get(),
            "fs": self.fs.get(),
            "rirLength": self.rirLength.get(),
            "micCoords": self.micCoords,
            "audioCoords": self.audioCoords,
            "noiseCoords": self.noiseCoords,
        }

        objs_str = [f">> {key}: {value}" for key, value in objs.items()]

        return "\n".join([strout] + objs_str)

    def make_window(self):
        """Generate GUI window"""
        ## Canvas for plotting the acoustic scenario
        canvasFrame = ttk.Frame(self.mainframe, padding=(3, 3, 12, 12))
        canvasFrame.grid(in_=self.mainframe, column=0, row=0, sticky="n")

        self.canvas = tk.Canvas(
            self.mainframe, width=500, height=500, background="white"
        )
        self.canvas.grid(column=0, row=0, padx=10, pady=10, sticky="nesw")
        self.canvas.bind("<Button-1>", self._on_click)
        self._draw_line_every_meter()

        ## Frame containing all options for the scenario
        optionFrame = ttk.Frame(self.mainframe, padding=(3, 3, 12, 12))
        optionFrame.grid(in_=self.mainframe, column=1, row=0, sticky="n")

        # Which type of entry to add
        optionLabel = ttk.Label(optionFrame, text="Add component")
        optionLabel.grid(column=0, row=0)

        mic = ttk.Radiobutton(
            optionFrame, text="Mic", variable=self.option, value="mic"
        )
        mic.grid(column=0, row=1, sticky="w")
        audio = ttk.Radiobutton(
            optionFrame, text="Audio", variable=self.option, value="audio"
        )
        audio.grid(column=0, row=2, sticky="w")
        noise = ttk.Radiobutton(
            optionFrame, text="Noise", variable=self.option, value="noise"
        )
        noise.grid(column=0, row=3, sticky="w")

        delMic = ttk.Button(optionFrame, text="Del", command=self._deleteMics)
        delMic.grid(column=1, row=1, sticky="e", padx=10, pady=10)
        delAudio = ttk.Button(optionFrame, text="Del", command=self._deleteAudio)
        delAudio.grid(column=1, row=2, sticky="e", padx=10, pady=10)
        delNoise = ttk.Button(optionFrame, text="Del", command=self._deleteNoise)
        delNoise.grid(column=1, row=3, sticky="e", padx=10, pady=10)

        # Configure microphone array
        nMicLabel = ttk.Label(optionFrame, text="# mics")
        nMicLabel.grid(column=0, row=4, sticky="w")
        nMicEntry = ttk.Entry(optionFrame, textvariable=self.nMicsPerArray)
        nMicEntry.grid(column=1, row=4, sticky="w", padx=10, pady=10)

        dBwMicsLabel = ttk.Label(optionFrame, text="d [cm]")
        dBwMicsLabel.grid(column=0, row=5, sticky="w")
        dBwMicsEntry = ttk.Entry(optionFrame, textvariable=self.distBwMics)
        dBwMicsEntry.grid(column=1, row=5, sticky="w", padx=10, pady=10)

        resetButton = ttk.Button(
            optionFrame, text="Reset Components", command=self._resetComponents
        )
        resetButton.grid(column=0, row=6, columnspan=2, sticky="we", padx=10, pady=10)

        ## Window to set parameters
        parameterFrame = ttk.Frame(self.mainframe, padding=(3, 3, 12, 12))
        parameterFrame.grid(in_=self.mainframe, column=2, row=0, sticky="n")
        parameterLabel = ttk.Label(parameterFrame, text="Parameters")
        parameterLabel.grid(row=0, column=0)

        roomDimLabel = ttk.Label(parameterFrame, text="Room dim [m]")
        roomDimLabel.grid(row=1, column=0, sticky="w")
        roomDimEntry = ttk.Entry(parameterFrame, textvariable=self.roomDim)
        self.roomDim.trace_add("write", lambda *args: self._resize_room())
        roomDimEntry.grid(row=1, column=1, sticky="e", padx=10, pady=10)

        t60Label = ttk.Label(parameterFrame, text="T60 [s]")
        t60Label.grid(row=2, column=0, sticky="w")
        t60Entry = ttk.Entry(parameterFrame, textvariable=self.t60)
        t60Entry.grid(row=2, column=1, sticky="e", padx=10, pady=10)

        lRIRLabel = ttk.Label(parameterFrame, text="Length RIR [samples]")
        lRIRLabel.grid(row=3, column=0, sticky="w")
        lRIREntry = ttk.Entry(parameterFrame, textvariable=self.rirLength)
        lRIREntry.grid(row=3, column=1, sticky="e", padx=10, pady=10)

        fsLabel = ttk.Label(parameterFrame, text="fs [Hz]")
        fsLabel.grid(row=4, column=0, sticky="w")
        fsEntry = ttk.Combobox(
            parameterFrame,
            textvariable=self.fs,
            values=[str(freq) for freq in self.allowed_fs],
            state="readonly",
        )
        fsEntry.grid(row=4, column=1, sticky="e")

        runButton = ttk.Button(
            parameterFrame, text="Create/store RIRs", command=self._computeRIRs
        )
        runButton.grid(row=6, column=0, columnspan=2, padx=10, pady=10, sticky="s")

        self.root.mainloop()

    def _draw_line_every_meter(self):
        """Draw a grid with size 1m on the canvas"""
        offset = 10  # ensure text does not overlap with lines

        roomDim = float(self.roomDim.get())

        width, height = int(self.canvas["width"]), int(self.canvas["height"])
        deltaLineW = width / roomDim
        deltaLineH = height / roomDim

        self.canvas.delete("all")  # only delete after conversions are safely done

        for i in range(int(np.floor(roomDim))):
            distW = int(i * deltaLineW)
            distH = int(i * deltaLineH)

            self.canvas.create_line(0, distW, height, distW, fill="gray")
            self.canvas.create_text(offset, distW - offset, text=f"{i} m", fill="gray")
            self.canvas.create_line(distH, 0, distH, width, fill="black")
            self.canvas.create_text(
                distH + offset * 3 / 2, offset, text=f"{i} m", fill="gray"
            )

    def _resize_room(self):
        self.micCoords = []
        self.audioCoords = []
        self.noiseCoords = []
        self._redraw_room()

    def _on_click(self, event: tk.Event):
        """Delete all previous elements and repaint canvas"""
        self.canvas.delete("all")

        x, y = event.x, event.y

        width = int(self.canvas["width"])  # square canvas
        height = width
        roomdim = float(self.roomDim.get())

        new_coord_x = x * roomdim / width
        new_coord_y = y * roomdim / height

        if self.option.get() == "mic":  # Only one mic array is allowed, hence replace
            offsetCM = float(self.distBwMics.get())
            nMics = int(self.nMicsPerArray.get())

            self.micCoords = [
                (new_coord_x, new_coord_y - i * offsetCM / 100) for i in range(nMics)
            ]

            # Prevent weird corner cases
            if np.any(np.asarray(self.micCoords) < 0) or np.any(
                np.asarray(self.micCoords) > roomdim
            ):
                print("/!\\ microphone array would not fit in the room, skipping.")
        elif self.option.get() == "audio":
            self.audioCoords.append((new_coord_x, new_coord_y))
        elif self.option.get() == "noise":
            self.noiseCoords.append((new_coord_x, new_coord_y))

        ## Redraw everything
        self._redraw_room()

    def _redraw_room(self):
        try:
            self._draw_line_every_meter()
            for mic in self.micCoords:
                guiCoord = self._convertMtoGUI(mic)
                self._drawElement(guiCoord, ELEMENT_COLORS["mic"])

            for source in self.audioCoords:
                guiCoord = self._convertMtoGUI(source)
                self._drawElement(guiCoord, ELEMENT_COLORS["audio"])

            for source in self.noiseCoords:
                guiCoord = self._convertMtoGUI(source)
                self._drawElement(guiCoord, ELEMENT_COLORS["noise"])

        except (ValueError, ZeroDivisionError) as _:  # just fail silently
            pass

    def _drawElement(self, coord: tuple[int, int], color: str):
        self.canvas.create_oval(
            coord[0] - ELEMENT_RADIUS / 2,
            coord[1] - ELEMENT_RADIUS / 2,
            coord[0] + ELEMENT_RADIUS / 2,
            coord[1] + ELEMENT_RADIUS / 2,
            fill=color,
        )

    def _convertMtoGUI(self, coord: tuple[float, float]) -> tuple[int, int]:
        roomDim = float(self.roomDim.get())
        guiDim = int(self.canvas["width"])

        gui_coord_x = int(coord[0] / roomDim * guiDim)
        gui_coord_y = int(coord[1] / roomDim * guiDim)

        return (gui_coord_x, gui_coord_y)

    def _deleteMics(self):
        self.micCoords = []
        self._redraw_room()

    def _deleteAudio(self):
        self.audioCoords = []
        self._redraw_room()

    def _deleteNoise(self):
        self.noiseCoords = []
        self._redraw_room()

    def _resetComponents(self):
        """
        Reset everything to default.
        """
        self._deleteMics()
        self._deleteAudio()
        self._deleteNoise()

        self.option.set("mic")
        self.nMicsPerArray.set(str(DEFAULT_NMICS))
        self.distBwMics.set(str(DEFAULT_DIST_BW_MICS))
        self.roomDim.set(str(DEFAULT_ROOMDIM))
        self.t60.set(str(DEFAULT_T60))
        self.rirLength.set(str(DEFAULT_RIR_LENGTH))
        self.fs.set(str(DEFAULT_FS))

    def _computeRIRs(self):
        """Perform some sanity checks, compute RIRs and dump results into file."""
        if len(self.micCoords) == 0:
            print("WARNING: no microphone array defined. Cannot compute RIRs.")
        elif len(self.audioCoords) == 0 and len(self.noiseCoords) == 0:
            print("WARNING: no source defined. Cannot compute RIRs.")
        else:
            # ===================================
            # If all good, compute and store RIRs
            # ===================================
            if len(self.micCoords) > 0:
                if len(self.audioCoords) == 0 and len(self.noiseCoords) == 0:
                    print(
                        "No sound source present. Please place audio and/or noise source(s) and try again."
                    )
                else:
                    now = datetime.now()
                    now = f"{now.year:02d}{now.month:02d}{now.day:02d}_{now.hour:02d}{now.minute:02d}{now.second:02d}"
                    fname = f"{self.exportFolder}/rirs_{now}"

                    if not os.path.isdir(self.exportFolder):
                        os.makedirs(self.exportFolder)

                    micPos = np.array(self.micCoords)
                    audioPos = np.array(self.audioCoords)
                    noisePos = np.array(self.noiseCoords)
                    roomDim = float(self.roomDim.get())
                    t60 = float(self.t60.get())
                    fs = int(self.fs.get())
                    rirLength = int(self.rirLength.get())

                    self.RIRsAudio, self.RIRsNoise = compute_rirs(
                        micPos, audioPos, noisePos, roomDim, t60, fs, rirLength
                    )
                    if (len(self.audioCoords) > 0 and self.RIRsAudio is None) or (
                        len(self.noiseCoords) > 0 and self.RIRsNoise is None
                    ):
                        print("RIRs computation failed. Please try again.")
                    else:
                        print("RIRs computed successfully. Saving as pickle archive.")
                        fullFname = fname + ".pkl"

                        archive: dict[str, object] = {}
                        archive["c"] = self.c
                        archive["t60"] = t60
                        archive["fs"] = fs
                        archive["roomDim"] = roomDim
                        archive["rirLength"] = rirLength
                        archive["micPos"] = micPos
                        archive["audioPos"] = (
                            audioPos if np.all(audioPos != np.array(None)) else None
                        )
                        archive["noisePos"] = (
                            noisePos if np.all(noisePos != np.array(None)) else None
                        )
                        archive["RIRs_audio"] = self.RIRsAudio
                        archive["RIRs_noise"] = self.RIRsNoise

                        with open(fullFname, "wb") as fd:
                            pickle.dump(archive, fd)
                        print(
                            f'RIRs saved in file: "{Path(fullFname).name}",'
                            f'in folder\n"{Path(fullFname).parent}"'
                        )
                        print("You may close the GUI if not needed anymore!")
            else:
                print(
                    "No microphones are present. Please place microphones and try again."
                )


def compute_rirs(
    micPos: np.ndarray,
    audioPos: np.ndarray,
    noisePos: np.ndarray,
    roomDim: float,
    t60: float,
    fsRIR: float,
    rirLength: int = None,
    c: float = 340,
) -> tuple[np.ndarray, np.ndarray]:
    """
    Computes RIRs based on MATLAB function from the KUL course "P&D ISSP 2022"
    `create_rirs.m`.
    Major difference: not using the `simroommex.m` MATLAB MEX file.
    Instead: pyroomacoustics Python package.

    Parameters
    ----------
    -micPos : [Nm x 2] np.ndarray (float)
        Microphones coordinates [m].
    -audioPos : [Ns x 2] np.ndarray (float)
        Sources coordinates [m].
    -noisePos : [Nn x 2] np.ndarray (float)
        Noise sources coordinates [m].
    -roomDim : float
        Room dimension [m].
    -t60 : float
        T60 reverberation time [s].
    -fsRIR : int or float
        RIR sampling rate [samples/s].
    -rirLength : int
        Impulse response length [samples].
    -c : float
        Speed of sound [m/s].

    Returns
    -------
    RIRsAudio : [`rirLength` x Nm x Ns] np.ndarray (float)
        RIRs between each audio source and each microphone.
    RIRsNoise : [`rirLength` x Nm x Nn] np.ndarray (float)
        RIRs between each noiise source and each microphone.
    """

    rd = [roomDim, roomDim, 4]  # Room dimensions [x, y, z] (m)
    nMics = micPos.shape[0]
    nAudio = audioPos.shape[0]
    nNoise = noisePos.shape[0]
    micPos3D = np.concatenate((micPos, np.full((nMics, 1), fill_value=2)), axis=1)
    if nAudio > 0:
        audioPos3D = np.concatenate(
            (audioPos, np.full((nAudio, 1), fill_value=2)), axis=1
        )
    if nNoise > 0:
        noisePos3D = np.concatenate(
            (noisePos, np.full((nNoise, 1), fill_value=2)), axis=1
        )

    if t60 != 0:  # check T60
        # Compute using Sabine's formula
        vol = np.prod(rd)
        surf = (rd[0] * rd[1] + rd[0] * rd[2] + rd[2] * rd[1]) * 2
        refl = np.amax((0, 1 - 0.161 * vol / (t60 * surf)))
        if refl > 0.92:  # hard threshold
            refl = 0.92
            t60 = 0.161 * vol / ((1 - refl) * surf)
            print(
                f"WARNING: too large reverberation time, RIRs created with reverberation time T60={np.round(t60, 3)} s"
            )

    if rirLength is None:
        rirLength = np.round(
            np.amax(t60 * 1.2 * fsRIR, 2 * fsRIR * np.amax(rd) / c)
        )  # Number of samples
        rirLength += rirLength % 2

    print(f"Note that the RIRs are sampled at {fsRIR} Hz.")

    # Invert Sabine's formula to obtain the parameters for the ISM simulator
    if t60 == 0:
        max_order = 0
        e_absorption = 0.5  # <-- arbitrary (unused)
    else:
        try:
            e_absorption, max_order = pra.inverse_sabine(t60, rd, c)
        except ValueError as err:
            print(
                f'/!\\ /!\\ PyRoomAcoustics failed to compute the RIRs. Error message:\n"{err}"'
            )
            print(
                "\nLarge room with small T60 do not work well together (too unrealistic)."
            )
            return None, None
    # Create source list
    if nAudio > 0 and nNoise > 0:
        sources = [pra.SoundSource(audioPos3D[ii, :]) for ii in range(nAudio)] + [
            pra.SoundSource(noisePos3D[ii, :]) for ii in range(nNoise)
        ]
    elif nAudio == 0 and nNoise > 0:
        sources = [pra.SoundSource(noisePos3D[ii, :]) for ii in range(nNoise)]
    elif nAudio > 0 and nNoise == 0:
        sources = [pra.SoundSource(audioPos3D[ii, :]) for ii in range(nAudio)]

    # Create acoustic environment (room)
    room: pra.ShoeBox = pra.ShoeBox(
        p=np.array(rd),  # room dimensions
        fs=fsRIR,
        t0=0,
        materials=pra.Material(e_absorption),
        max_order=max_order,
        sources=sources,
    )
    room.add_microphone_array(micPos3D.T)  # add microphones

    # Compute RIRs
    print(f"PyRoomAcoustics is computing the {int(nMics * (nAudio + nNoise))} RIRs...")
    room.compute_rir()
    print("Computation done.")

    # Post-process RIRs
    if nAudio > 0:
        RIRsAudio = np.zeros((rirLength, nMics, nAudio))
    else:
        RIRsAudio = None
    if nNoise > 0:
        RIRsNoise = np.zeros((rirLength, nMics, nNoise))
    else:
        RIRsNoise = None
    for ii in range(nMics):
        currRIRs = room.rir[ii]  # ty: ignore
        for jj in range(nAudio):
            if len(currRIRs[jj]) < rirLength:
                RIRsAudio[:, ii, jj] = np.concatenate(  # ty: ignore
                    (currRIRs[jj], np.zeros(rirLength - len(currRIRs[jj])))
                )
            else:
                RIRsAudio[:, ii, jj] = currRIRs[jj][:rirLength]  # ty: ignore
                print(
                    f"/!\\ Truncated PyRoomAcoustics RIR! (mic #{ii + 1} - audio source #{jj + 1})"
                )
        for jj in range(nNoise):
            if len(currRIRs[nAudio + jj]) < rirLength:
                RIRsNoise[:, ii, jj] = np.concatenate(  # ty: ignore
                    (
                        currRIRs[nAudio + jj],
                        np.zeros(rirLength - len(currRIRs[nAudio + jj])),
                    )
                )
            else:
                RIRsNoise[:, ii, jj] = currRIRs[nAudio + jj][:rirLength]  # ty: ignore
                print(
                    f"/!\\ Truncated PyRoomAcoustics RIR! (mic #{ii + 1} - noise source #{jj + 1})"
                )

    return RIRsAudio, RIRsNoise


def load_rirs(path: str) -> Asc:
    """
    Utility function that automatically converts the dict returned from the
    pickle archive into a class.
    """
    with open(path, "rb") as fd:
        data = pickle.load(fd)

    return Asc(
        data["c"],
        data["t60"],
        data["fs"],
        data["roomDim"],
        data["rirLength"],
        data["micPos"],
        data["audioPos"],
        data["noisePos"],
        data["RIRs_audio"],
        data["RIRs_noise"],
    )


def plot_rirs(RIRsAudio, RIRsNoise) -> Figure:
    """
    Output a plot of the RIRs.
    """
    nMics = RIRsAudio.shape[1]
    if RIRsAudio is not None:
        nAudio = RIRsAudio.shape[-1]
    else:
        nAudio = 0
    if RIRsNoise is not None:
        nNoise = RIRsNoise.shape[-1]
    else:
        nNoise = 0
    nCols = 1
    if nAudio > 0 and nNoise > 0:
        nCols = 2
    nRows = np.amax((nAudio, nNoise))

    fig, axes = plt.subplots(nRows, nCols)
    fig.set_size_inches(8.5, 3.5 / 3 * nMics * nRows)
    for ii in range(nRows):
        for jj in range(nCols):
            if jj == 0:
                if nAudio > 0:
                    if ii < nAudio:
                        RIRsCurr = RIRsAudio[:, :, ii]
                        title = f"Audio source {ii + 1}"
                    else:
                        RIRsCurr = None
                        title = ""
                elif nNoise > 0 and nAudio == 0:
                    if ii < nNoise:
                        RIRsCurr = RIRsNoise[:, :, ii]
                        title = f"Noise source {ii + 1}"
                    else:
                        RIRsCurr = None
                        title = ""
            elif jj == 1:
                if ii < nNoise:
                    RIRsCurr = RIRsNoise[:, :, ii]
                    title = f"Noise source {ii + 1}"
                else:
                    RIRsCurr = None
                    title = ""
            # One subplot per source
            if not isinstance(axes, np.ndarray):
                currAx = axes
            elif len(axes.shape) == 2:
                currAx = axes[ii, jj]
            elif nRows > 1:
                currAx = axes[ii]
            elif nCols > 1:
                currAx = axes[jj]
            # Plot
            if RIRsCurr is not None:
                for kk in range(nMics):
                    delta = np.amax(np.abs(RIRsCurr))
                    currAx.plot(RIRsCurr[:, kk].T - kk * delta, label=f"Mic. #{kk + 1}")
                currAx.grid()
                currAx.set_title(title)
                currAx.set_xlabel("Samples")
                if ii == 0 and jj == 0:
                    currAx.legend(loc="upper right")
    plt.tight_layout()

    return fig


def plot_asc(asc: Asc) -> Figure:
    """
    Make a plot of the given acoustic scenario and return the corresponding figure.
    """

    fig, ax = plt.subplots()

    ax.set_aspect("equal")
    ax.set(xlim=[0, asc.roomDim], xlabel="x [m]", ylim=[0, asc.roomDim], ylabel="y [m]")
    ax.set_xticks(np.arange(np.floor(asc.roomDim)))
    ax.set_yticks(np.arange(np.floor(asc.roomDim)))
    ax.grid(True)

    for i in range(asc.micPos.shape[0]):
        ax.scatter(x=asc.micPos[i, 0], y=asc.micPos[i, 1], c=ELEMENT_COLORS["mic"])
        ax.text(
            x=asc.micPos[i, 0],
            y=asc.micPos[i, 1],
            c=ELEMENT_COLORS["mic"],
            s=f"m{i + 1}",
        )

    if asc.audioPos is not None:
        for i in range(asc.audioPos.shape[0]):
            ax.scatter(
                x=asc.audioPos[i, 0], y=asc.audioPos[i, 1], c=ELEMENT_COLORS["audio"]
            )
            ax.text(
                x=asc.audioPos[i, 0],
                y=asc.audioPos[i, 1],
                c=ELEMENT_COLORS["audio"],
                s=f"a{i + 1}",
            )

    if asc.noisePos is not None:
        for i in range(asc.noisePos.shape[0]):
            ax.scatter(
                x=asc.noisePos[i, 0], y=asc.noisePos[i, 1], c=ELEMENT_COLORS["noise"]
            )
            ax.text(
                x=asc.noisePos[i, 0],
                y=asc.noisePos[i, 1],
                c=ELEMENT_COLORS["noise"],
                s=f"n{i + 1}",
            )

    return fig
